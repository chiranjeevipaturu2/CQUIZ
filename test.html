<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taking Test - CQUIZ</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        .q-panel {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .q-panel.active {
            display: block;
        }
    </style>
</head>

<body>
    <!-- Timer UI -->
    <div id="timerDisplay"
        style="position: fixed; top: 1rem; right: 10rem; font-family: monospace; font-size: 1.2rem; font-weight: 700; background: rgba(0,0,0,0.3); padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); display: none; z-index: 100;">
        00:00:00
    </div>

    <div class="container"
        style="max-width: 800px; height: 100vh; display: flex; flex-direction: column; justify-content: center;">

        <!-- Header: Timer & Submit -->
        <div class="glass-card mb-4 flex-between" style="padding: 1rem 2rem;">
            <h3 id="testTitle">Test Name</h3>
            <div style="display: flex; gap: 1rem; align-items: center;">
                <div id="questionNav" class="question-nav" style="max-width: 200px;">
                    <!-- Circles generated here -->
                </div>
                <button onclick="submitTest()" class="btn btn-primary">Submit Test</button>
            </div>
        </div>

        <!-- Question Card -->
        <div class="glass-card"
            style="min-height: 400px; display: flex; flex-direction: column; justify-content: space-between;">
            <div id="questionsContainer">
                <!-- Questions injected here -->
            </div>

            <!-- Navigation Controls -->
            <div class="flex-between mt-4 border-t"
                style="padding-top: 1rem; border-top: 1px solid var(--border-glass);">
                <button id="prevBtn" class="btn btn-secondary" onclick="changeQ(-1)">Previous</button>
                <span class="text-muted" id="qProgress">1 / X</span>
                <button id="nextBtn" class="btn btn-secondary" onclick="changeQ(1)">Next</button>
            </div>
        </div>

    </div>

    <script src="script.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBaA9KJKtszg7SPU3PJfil4vLg_ckZz6ys",
            authDomain: "cquiz-7955e.firebaseapp.com",
            projectId: "cquiz-7955e",
            storageBucket: "cquiz-7955e.firebasestorage.app",
            messagingSenderId: "931716478360",
            appId: "1:931716478360:web:4f2a5406e42ee5a2ba27ed",
            measurementId: "G-TM63LXHVHM"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Global helper for submissions
        window.saveResultToFirestore = async (result) => {
            try {
                const resId = Date.now().toString(36);
                await setDoc(doc(db, "submissions", resId), result);
            } catch (err) {
                console.error("Firestore Save Error:", err);
            }
        };

        async function startTest() {
            const user = requireAuth('student');
            const params = new URLSearchParams(window.location.search);
            const testId = params.get('id');

            let test = null;

            // 1) Any number of attempts allowed (Attempt limit check removed as requested)

            try {
                // Try Firestore first
                const docSnap = await getDoc(doc(db, "tests", testId));
                if (docSnap.exists()) {
                    test = { id: docSnap.id, ...docSnap.data() };
                }
            } catch (err) {
                console.warn("Firestore fetch error, falling back to local:", err);
            }

            if (!test) {
                const tests = getTests();
                test = tests.find(t => t.id === testId);
            }

            if (!test) {
                alert('Test not found');
                window.location.href = 'student.html';
                return;
            }

            // --- DATA NORMALIZATION (Firestore Safety) ---
            if (test.questions && !Array.isArray(test.questions)) {
                test.questions = Object.values(test.questions);
            }
            if (!test.questions || test.questions.length === 0) {
                alert('This test has no questions.');
                window.location.href = 'student.html';
                return;
            }

            document.getElementById('testTitle').textContent = test.title;

            const answers = {};
            const viewedQuestions = new Set();
            let timerInterval;

            const ExamLockdown = {
                isActive: false,
                examStarted: false,
                isTerminated: false,

                async checkPreviousAttempt() {
                    try {
                        const q = query(collection(db, "attempts"),
                            where("studentRoll", "==", user.roll),
                            where("testId", "==", testId),
                            where("status", "==", "terminated")
                        );
                        const querySnapshot = await getDocs(q);
                        if (!querySnapshot.empty) {
                            this.showTerminationScreen("Previous attempt was terminated. You cannot re-enter.");
                            return true;
                        }
                    } catch (err) {
                        console.error("Check attempt error:", err);
                    }
                    return false;
                },

                enable() {
                    if (!this.examStarted || this.isTerminated) return;
                    if (this.isActive) return;
                    this.isActive = true;

                    document.addEventListener('fullscreenchange', this.handleFullscreenChange);
                    window.addEventListener('keydown', this.handleKeydown, true);
                    document.addEventListener('contextmenu', this.handleContextMenu);
                    document.addEventListener('selectstart', this.handleSelectStart);
                    document.addEventListener('dragstart', this.handleDragStart);

                    // New detection listeners
                    document.addEventListener('visibilitychange', this.handleVisibilityChange);
                    window.addEventListener('blur', this.handleBlur);
                    window.addEventListener('beforeunload', this.handleBeforeUnload);

                    document.body.style.userSelect = 'none';
                    document.body.style.webkitUserSelect = 'none';
                },

                disable() {
                    this.isActive = false;
                    this.examStarted = false;
                    document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
                    window.removeEventListener('keydown', this.handleKeydown, true);
                    document.removeEventListener('contextmenu', this.handleContextMenu);
                    document.removeEventListener('selectstart', this.handleSelectStart);
                    document.removeEventListener('dragstart', this.handleDragStart);

                    document.removeEventListener('visibilitychange', this.handleVisibilityChange);
                    window.removeEventListener('blur', this.handleBlur);
                    window.removeEventListener('beforeunload', this.handleBeforeUnload);

                    document.body.style.userSelect = 'auto';
                    document.body.style.webkitUserSelect = 'auto';
                },

                handleFullscreenChange: () => {
                    if (!ExamLockdown.examStarted || ExamLockdown.isTerminated) return;
                    if (!document.fullscreenElement && ExamLockdown.isActive) {
                        ExamLockdown.terminateExam("Fullscreen exited");
                    }
                },

                handleVisibilityChange: () => {
                    if (document.visibilityState === 'hidden' && ExamLockdown.isActive) {
                        ExamLockdown.terminateExam("Tab switching detected");
                    }
                },

                handleBlur: () => {
                    if (ExamLockdown.isActive) {
                        ExamLockdown.terminateExam("Focus lost / Alt+Tab detected");
                    }
                },

                handleBeforeUnload: (e) => {
                    if (ExamLockdown.isActive) {
                        // Attempt logging on refresh if possible
                        ExamLockdown.terminateExam("Page refresh/reload detected");
                        e.preventDefault();
                        e.returnValue = '';
                    }
                },

                async terminateExam(reason) {
                    if (this.isTerminated) return;
                    this.isTerminated = true;
                    this.isActive = false;
                    this.disable();

                    if (timerInterval) clearInterval(timerInterval);
                    localStorage.removeItem(TIMER_KEY);
                    sessionStorage.removeItem(SHUFFLE_KEY);

                    // Calculate stats so far
                    let attempted = 0;
                    let correct = 0;
                    let wrong = 0;
                    test.questions.forEach((q, originalIdx) => {
                        if (answers.hasOwnProperty(originalIdx)) {
                            attempted++;
                            const cIdx = q.sessionCorrectIndex !== undefined ? q.sessionCorrectIndex : q.correctIndex;
                            if (answers[originalIdx] === cIdx) correct++;
                            else wrong++;
                        }
                    });

                    // Log to Firestore
                    try {
                        const attemptId = `term_${user.roll}_${testId}_${Date.now()}`;
                        await setDoc(doc(db, "attempts", attemptId), {
                            userIdentifier: user.roll,
                            studentRoll: user.roll,
                            testId: testId,
                            terminationReason: reason,
                            timestamp: Date.now(),
                            status: "terminated",
                            stats: { attempted, correct, wrong, score: correct }
                        });
                    } catch (err) {
                        console.error("Failed to log termination:", err);
                    }

                    this.showTerminationScreen(reason, { attempted, correct, wrong });
                },

                showTerminationScreen(reason, stats = null) {
                    let statsHTML = "";
                    if (stats) {
                        statsHTML = `
                            <div class="glass-card mb-4" style="background: rgba(255,255,255,0.03); padding: 1.5rem; text-align: left; border: 1px solid rgba(255,255,255,0.05);">
                                <h3 style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--primary);">Your performance for this attempt:</h3>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                                    <div>
                                        <p class="text-muted" style="font-size: 0.9rem;">Attempted</p>
                                        <p style="font-size: 1.25rem; font-weight: 700;">${stats.attempted}</p>
                                    </div>
                                    <div>
                                        <p class="text-muted" style="font-size: 0.9rem;">Score</p>
                                        <p style="font-size: 1.25rem; font-weight: 700; color: var(--primary);">${stats.correct}</p>
                                    </div>
                                    <div>
                                        <p class="text-muted" style="font-size: 0.9rem;">Correct</p>
                                        <p style="font-size: 1.1rem; color: #6ee7b7;">${stats.correct}</p>
                                    </div>
                                    <div>
                                        <p class="text-muted" style="font-size: 0.9rem;">Wrong</p>
                                        <p style="font-size: 1.1rem; color: #f472b6;">${stats.wrong}</p>
                                    </div>
                                </div>
                            </div>
                        `;
                    }

                    document.body.innerHTML = `
                        <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0a0a0f; display: flex; align-items: center; justify-content: center; z-index: 10000; font-family: 'Outfit', sans-serif;">
                            <div class="glass-card text-center" style="padding: 3rem; max-width: 550px; border: 1px solid rgba(239, 68, 68, 0.2); box-shadow: 0 0 50px rgba(239, 68, 68, 0.1);">
                                <svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: #ef4444; margin-bottom: 1.5rem;">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="15" y1="9" x2="9" y2="15"></line>
                                    <line x1="9" y1="9" x2="15" y2="15"></line>
                                </svg>
                                <h1 style="font-size: 2.5rem; margin-bottom: 0.5rem; color: #fff;">Exam Terminated</h1>
                                <p style="font-size: 1.1rem; color: #ef4444; margin-bottom: 2rem; font-weight: 600;">Reason: ${reason}</p>
                                
                                ${statsHTML}

                                <div class="mb-4" style="color: var(--text-muted); line-height: 1.6; font-size: 0.95rem;">
                                    This attempt has been logged as terminated due to a security violation. 
                                    The current attempt cannot be resumed, but you may start a new test. 
                                </div>

                                <button onclick="window.location.href='student.html'" class="btn btn-primary" style="padding: 0.8rem 2rem;">Return to Dashboard</button>
                            </div>
                        </div>
                    `;
                },

                handleKeydown: (e) => {
                    if (!ExamLockdown.examStarted) return;
                    const forbiddenKeys = ['c', 'v', 'x', 'a', 'u', 's', 'p'];
                    if ((e.ctrlKey || e.metaKey) && forbiddenKeys.includes(e.key.toLowerCase())) { e.preventDefault(); return false; }
                    if ((e.ctrlKey || e.metaKey) && e.shiftKey && ['i', 'j', 'c'].includes(e.key.toLowerCase())) { e.preventDefault(); return false; }
                    if (['f11', 'f12'].includes(e.key.toLowerCase())) { e.preventDefault(); return false; }
                },

                handleContextMenu: (e) => { if (ExamLockdown.examStarted) e.preventDefault(); },
                handleSelectStart: (e) => { if (ExamLockdown.examStarted) e.preventDefault(); },
                handleDragStart: (e) => { if (ExamLockdown.examStarted) e.preventDefault(); },
            };

            const TIMER_KEY = `cquiz_start_${testId}_${user.roll}`;
            const SHUFFLE_KEY = `cquiz_order_${testId}_${user.roll}`;

            let questionOrder = [];
            if (test.shuffleEnabled) {
                const savedOrder = JSON.parse(sessionStorage.getItem(SHUFFLE_KEY));
                if (savedOrder && savedOrder.length === test.questions.length) {
                    questionOrder = savedOrder;
                } else {
                    questionOrder = test.questions.map((_, i) => i);
                    for (let i = questionOrder.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [questionOrder[i], questionOrder[j]] = [questionOrder[j], questionOrder[i]];
                    }
                    sessionStorage.setItem(SHUFFLE_KEY, JSON.stringify(questionOrder));
                }
            } else { questionOrder = test.questions.map((_, i) => i); }

            function initTimer() {
                if (!test.durationInSeconds || test.durationInSeconds <= 0) return;
                const timerDisplay = document.getElementById('timerDisplay');
                timerDisplay.style.display = 'inline-block';
                timerDisplay.style.position = 'static';
                timerDisplay.style.marginRight = '1rem';
                const submitBtn = document.querySelector('button[onclick="submitTest()"]');
                if (submitBtn) submitBtn.parentElement.insertBefore(timerDisplay, submitBtn);

                let startTime = localStorage.getItem(TIMER_KEY);
                if (!startTime) { startTime = Date.now(); localStorage.setItem(TIMER_KEY, startTime); }
                else { startTime = parseInt(startTime); }

                const endTime = startTime + (test.durationInSeconds * 1000);
                function updateTimer() {
                    const diff = endTime - Date.now();
                    if (diff <= 0) {
                        timerDisplay.textContent = "00:00:00";
                        if (timerInterval) clearInterval(timerInterval);
                        submitTest(true);
                        return;
                    }
                    const h = Math.floor(diff / 3600000);
                    const m = Math.floor((diff % 3600000) / 60000);
                    const s = Math.floor((diff % 60000) / 1000);
                    timerDisplay.textContent = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                }
                updateTimer();
                timerInterval = setInterval(updateTimer, 1000);
            }

            const qContainer = document.getElementById('questionsContainer');
            const navContainer = document.getElementById('questionNav');

            function escapeHTML(str) {
                if (typeof str !== "string") return "";
                return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            questionOrder.forEach((originalIdx, displayIdx) => {
                const q = test.questions[originalIdx];
                let rawOptions = [];
                try {
                    if (q.options) {
                        if (Array.isArray(q.options)) rawOptions = [...q.options];
                        else if (typeof q.options === "object") rawOptions = Object.values(q.options);
                    }
                } catch (e) { rawOptions = []; }

                const mappedOptions = rawOptions.map((opt, idx) => ({ text: opt, originalIdx: idx }));
                const shuffled = shuffleArray([...mappedOptions]);
                q.sessionCorrectIndex = shuffled.findIndex(o => o.originalIdx === q.correctIndex);

                const panel = document.createElement('div');
                panel.className = `q-panel ${displayIdx === 0 ? 'active' : ''}`;
                panel.id = `q-panel-${displayIdx}`;

                const qText = q.question || q.text || q.questionText || `Question ${displayIdx + 1}`;
                panel.innerHTML = `
                    <div style="padding: 10px;">
                        <h3 class="mb-4" style="color: var(--primary);">Question ${displayIdx + 1}</h3>
                        <p class="mb-4" style="font-size: 1.25rem; font-weight: 500; line-height: 1.4;">${escapeHTML(qText)}</p>
                        <div class="options-list" style="display: flex; flex-direction: column; gap: 12px; margin-top: 20px;">
                            ${shuffled.length > 0 ? shuffled.map((opt, optIdx) => {
                    const optText = (typeof opt.text === 'object' && opt.text !== null) ? (opt.text.text || opt.text.value || Object.values(opt.text)[0]) : opt.text;
                    return `
                                <div class="option-label" data-display="${displayIdx}" data-original="${originalIdx}" data-opt="${optIdx}"
                                     style="display:flex; align-items:center; padding:15px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:12px; cursor:pointer; transition:all 0.2s;">
                                    <div class="option-circle" style="width:20px; height:20px; border:2px solid var(--text-muted); border-radius:50%; margin-right:15px; flex-shrink:0; display:flex; align-items:center; justify-content:center;">
                                        <div class="dot" style="width:10px; height:10px; background:var(--primary); border-radius:50%; opacity:0; transition:opacity 0.2s;"></div>
                                    </div>
                                    <span style="font-size: 1.05rem;">${escapeHTML(String(optText))}</span>
                                </div>`;
                }).join('') : `<div style="padding:20px; background:rgba(239,68,68,0.1); border:1px dashed var(--error); border-radius:12px; color:var(--error);"><strong>[!] Data Error:</strong> No options found.</div>`}
                        </div>
                    </div>`;
                qContainer.appendChild(panel);
                panel.querySelectorAll('.option-label').forEach(label => {
                    label.addEventListener('click', function () {
                        selectOption(parseInt(this.getAttribute('data-display')), parseInt(this.getAttribute('data-original')), parseInt(this.getAttribute('data-opt')), this);
                    });
                });
                const dot = document.createElement('div');
                dot.className = `nav-item ${displayIdx === 0 ? 'active' : ''}`;
                dot.textContent = displayIdx + 1;
                dot.onclick = () => jumpToQ(displayIdx);
                navContainer.appendChild(dot);
            });

            function selectOption(displayIdx, originalIdx, optIdx, labelEl) {
                answers[originalIdx] = optIdx;
                const panel = document.getElementById(`q-panel-${displayIdx}`);
                panel.querySelectorAll('.option-label').forEach(l => {
                    l.style.background = 'rgba(255,255,255,0.05)';
                    l.style.borderColor = 'rgba(255,255,255,0.1)';
                    const circ = l.querySelector('.option-circle'), d = l.querySelector('.dot');
                    if (circ) circ.style.borderColor = 'var(--text-muted)';
                    if (d) d.style.opacity = '0';
                });
                labelEl.style.background = 'rgba(99, 102, 241, 0.15)';
                labelEl.style.borderColor = 'var(--primary)';
                const activeCirc = labelEl.querySelector('.option-circle'), activeDot = labelEl.querySelector('.dot');
                if (activeCirc) activeCirc.style.borderColor = 'var(--primary)';
                if (activeDot) activeDot.style.opacity = '1';
                updateNavStatus(displayIdx);
            }

            function updateNavStatus(displayIdx) {
                const originalIdx = questionOrder[displayIdx];
                const dot = navContainer.children[displayIdx];
                if (!dot) return;
                dot.classList.remove('answered', 'viewed');
                if (answers.hasOwnProperty(originalIdx)) dot.classList.add('answered');
                else if (viewedQuestions.has(displayIdx)) dot.classList.add('viewed');
            }

            let currentQIndex = 0;
            window.jumpToQ = (index) => {
                if (index < 0 || index >= questionOrder.length) return;
                const prev = document.getElementById(`q-panel-${currentQIndex}`);
                if (prev) prev.classList.remove('active');
                if (navContainer.children[currentQIndex]) navContainer.children[currentQIndex].classList.remove('active');
                updateNavStatus(currentQIndex);
                currentQIndex = index;
                const curr = document.getElementById(`q-panel-${currentQIndex}`);
                if (curr) curr.classList.add('active');
                if (navContainer.children[currentQIndex]) navContainer.children[currentQIndex].classList.add('active');
                viewedQuestions.add(currentQIndex);
                updateNavStatus(currentQIndex);
                updateControls();
            };

            window.changeQ = (dir) => jumpToQ(currentQIndex + dir);
            function updateControls() {
                const prevBtn = document.getElementById('prevBtn'), nextBtn = document.getElementById('nextBtn');
                prevBtn.disabled = currentQIndex === 0;
                prevBtn.style.opacity = currentQIndex === 0 ? '0.5' : '1';
                const isLast = currentQIndex === questionOrder.length - 1;
                if (isLast) { nextBtn.textContent = 'Finish'; nextBtn.onclick = () => submitTest(false); }
                else { nextBtn.textContent = 'Next'; nextBtn.onclick = () => changeQ(1); }
                document.getElementById('qProgress').textContent = `${currentQIndex + 1} / ${questionOrder.length}`;
            }

            window.submitTest = async function (force = false) {
                if (!force && !confirm('Are you sure you want to finish the test?')) return;
                ExamLockdown.disable();
                if (timerInterval) clearInterval(timerInterval);
                localStorage.removeItem(TIMER_KEY);
                sessionStorage.removeItem(SHUFFLE_KEY);
                let score = 0;
                test.questions.forEach((q, originalIdx) => {
                    const cIdx = q.sessionCorrectIndex !== undefined ? q.sessionCorrectIndex : q.correctIndex;
                    if (answers[originalIdx] === cIdx) score++;
                });
                const result = { testId: test.id, testTitle: test.title, studentRoll: user.roll, score, total: test.questions.length, timestamp: Date.now(), answers };
                saveResult(result);
                if (window.saveResultToFirestore) await window.saveResultToFirestore(result);
                window.location.href = `result.html?score=${score}&total=${test.questions.length}`;
            };

            function showStartOverlay() {
                const overlay = document.createElement('div');
                overlay.style = "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 10, 15, 0.98); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(10px);";
                overlay.innerHTML = `
                    <div class="glass-card text-center slide-up" style="padding: 3rem; max-width: 600px; border: 1px solid rgba(255,255,255,0.1);">
                        <h2 class="mb-4">Exam Instructions</h2>
                        <div class="text-muted mb-4" style="text-align: left; line-height: 1.8;">
                            <ul style="list-style: none; padding: 0;">
                                <li class="mb-2">• This is a monitored digital assessment.</li>
                                <li class="mb-2">• This test must be taken in Fullscreen Mode.</li>
                                <li class="mb-2">• Switching browser/Exiting fullscreen mode will terminate the exam.</li>
                                <li class="mb-2">• Once terminated, the current attempt cannot be resumed.</li>
                                <li class="mb-2">• When time expires, test auto-submits instantly.</li>
                                <li class="mb-4">• Ensure stable internet connectivity before starting.</li>
                            </ul>
                        </div>
                        <button id="startExamBtn" class="btn btn-primary btn-lg">Start Exam in Fullscreen</button>
                    </div>
                `;
                document.body.appendChild(overlay);

                document.getElementById('startExamBtn').onclick = () => {
                    const elem = document.documentElement;
                    if (elem.requestFullscreen) {
                        elem.requestFullscreen().catch(() => { });
                    }
                    overlay.remove();
                    ExamLockdown.examStarted = true;
                    ExamLockdown.enable();
                    initTimer();
                };
            }

            viewedQuestions.add(0);
            updateControls();
            updateNavStatus(0);

            showStartOverlay();
        }

        try {
            startTest();
        } catch (err) {
            console.error("Critical Student Page Error:", err);
            alert("An error occurred while loading the test. Check console.");
        }
    </script>
</body>

</html>
